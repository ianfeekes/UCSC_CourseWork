# -*- coding: utf-8 -*-
"""assignment_1__programming.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14Ixe7ZnzcxawuUcB6nlVvxLBvm7-Wj1p

# CMPS 140
"""

class Node:
    """
    This class describes a single node contained within a graph. 
    It has the following instan0ce level attributes:
    
    ID: An integer id for the node i.e. 1
    heuristic_cost: A float value representing the estimated 
                    cost to the goal node
    """    
    def __init__(self, ID, heuristic_cost):
        self.ID = ID
        self.connected_nodes = []
        self.heuristic_cost = heuristic_cost
        
    def __repr__(self):
        ID = self.ID
        hx = self.heuristic_cost
        if len(self.connected_nodes)==0:
            nodes = 'None'
        else:
            nodes = ','.join(str(cn[1].ID) for cn in self.connected_nodes)
        return 'Node:{}\nh(n):{}\nConnected Nodes:{}'.format(ID, hx, nodes)
        
    def set_connected_nodes(self,connected_nodes):
        """
        Adds edges that lead from this node to other nodes:
        
        Parameters:
        - connected_nodes: A list of tuples consisting of (cost, Node), 
                           where 'cost' is a floating point value 
                           indicating the cost to get from this node 
                           to 'Node' and 'Node' is a Node object
        """
        self.connected_nodes = connected_nodes
    
def build_graph():
    """
    Builds the graph to be parsed by the search algorithms.
    Returns: The starting node, which is the entry point into the graph
    """
    ids = range(13)
    coords = [(0,0), (1,1), (1,0), (1,1), (5,2), (3,1), (3,0), 
              (3,-1), (5,1), (4,1), (4,0), (4,-2), (7,0)]
    
    #https://en.wikipedia.org/wiki/Euclidean_distance
    euclidean_distance = lambda x1y1, x2y2: ((x1y1[0]-x2y2[0])**2 +  (x1y1[1]-x2y2[1])**2)**(0.5)
    
    def build_connected_node_list(from_id, to_ids):
        starting_coords = coords[from_id]
        
        connected_nodes = []
        for to_id in to_ids:
            connected_nodes.append((euclidean_distance(starting_coords, coords[to_id]), all_nodes[to_id]))
            
        return connected_nodes
    
    goal_coords = (7,0)
    all_nodes = [Node(_id, euclidean_distance(coord, goal_coords)) for _id, coord in zip(ids, coords)]
    
    all_nodes[8].set_connected_nodes(build_connected_node_list(8, [12]))
    all_nodes[10].set_connected_nodes(build_connected_node_list(10,[12]))
    all_nodes[5].set_connected_nodes(build_connected_node_list(5, [8]))
    all_nodes[6].set_connected_nodes(build_connected_node_list(6, [9, 10]))
    all_nodes[7].set_connected_nodes(build_connected_node_list(7, [11]))
    all_nodes[1].set_connected_nodes(build_connected_node_list(1, [4,5]))
    all_nodes[2].set_connected_nodes(build_connected_node_list(2, [5,6]))
    all_nodes[3].set_connected_nodes(build_connected_node_list(3, [7]))
    all_nodes[0].set_connected_nodes(build_connected_node_list(0, [1,2,3]))
    
    return all_nodes[0]

# The starting node. You can use this cell to familiarize
# yourself with the node/graph structure
build_graph()

"""## Question 1

![graph](https://docs.google.com/drawings/d/e/2PACX-1vStncj9Nc0LddQeViaYnykNxEZsJoYJMHhub2LLX8s7k7gwYjlnlt0cCcivymFihiZyOOMtHwzk1Z4G/pub?w=960&amp;h=720)

Given the above graph implement the following search algorithms:

1. **Depth First Search** (Graph Style) (Textbook Section 3.4.3)
2. **Iterative Deepening Depth-First Search** (Textbook Section 3.4.5)
3. **A* Search** (A-Star) (Textbook Section 3.5.2)



You will implement each of these search algorithms as a function with the following signature:

```python
def search_algorithm(starting_node, goal_node):
    '''
    This function implements a search algorithm.
    Parameters:
    - starting_node: The entry node into the graph
    - goal_node: The integer ID of the goal node.
    
    Returns:
    A list containing the visited node ids in order they were visited with starting node
    always being the first node and the goal node always being the last
    '''
    
    visited_nodes_in_order = []
    
    # algorithm implemented here
    
    return visited_nodes_in_order
```


I have put skeleton methods for each of the algorithms for you to fill in.

Here are the pseudo code/descriptions implemenatations from the book.

# Depth First Search
---
![dfs.png](https://lh3.googleusercontent.com/y8b0v4eTG2xfUqkWFm7H_RTb_sJ1ERBiyfWjkClb7GtRUsbAFwpECMnL9JfyTcY4AAhBhCWQiQlLhAmWPQLAN_6Ja_WMFEn5U0PoXaPqNJvKjEf9hW6Meq5xyHdygXqB-WzdBRmVEA=w2400)
![dfs-desc.png](https://lh3.googleusercontent.com/dIDKkPQZ7Vn-HfQ0WPlpthT_RkrQ86lH11hjLceUcDvFF2BCZs2RrfRfEiXgpZVG35vkGkLg6q3nISYeEUriPfwVxSNmhxOO0Gujl43G1lRsN8dTBTaxT8baX8tMu0st49R_CsWBKw=w2400)

# Iterative Deepening Depth First Search
---
![iddfs.png](https://lh3.googleusercontent.com/HrkCyMnoMPZoDELRdqx1cakdgA2rPZ2ImIg5n5XE-A5MXwHch7ZZ6uBE4vmVXv34V6BRFOgyrHl6aTXMm0qijA8s47zda7s9dKDDYzEH1mTnhEPWvOM9r1gE1wwXfXP0_3T22zFO0Q=w2400)
![dls.png](https://lh3.googleusercontent.com/w78lEVXUJitCh8WebB49DACKztyErtXTPi4ybHE0ai5L1orFkdYMtc7AfzdiXF1uuotahgqXoYHeaBpeExztTFR0GvKMIE4ddrYoHe6qSea3zL9TQh6LRYHV69cA3pXGt1nyl3Injg=w2400)

# A* Search
---
![astar](https://lh3.googleusercontent.com/Mp31KIl0a7Eu3ky0WU2QaqMBaAZRFH2ed48ua0dAr-P7GQqwyyYi7MT0NzP-2yaF-YQaykasARoUUUolghYc_Vszd4JCYSbKHQMUaAiT2Np9Khypz7NhwMhDOybJGJPdb1e_6oU1RQ=w2400)

# NOTES
---
 - If two nodes are considered equally good chocices, take the node with the lower ID first. 
 - Do not revisit already explored nodes when implementing the Depth First Search.
"""

def depth_first_search(starting_node, goal_node):
    """
    This function implements the depth first search algorithm
    
    Parameters:
    - starting_node: The entry node into the graph
    - goal_node: The integer ID of the goal node.
    
    Returns:
    A list containing the visited nodes in order they were visited with starting node
    always being the first node and the goal node always being the last
    """
    
    #Deals with trivial case first 
    if starting_node.ID == goal_node: return starting_node.ID  
    #Appends children of root to the frontier
    frontier = starting_node.connected_nodes  
    #We always begin by visiting the root
    visited_nodes_in_order = []
    visited_nodes_in_order.append(starting_node.ID)
    while frontier != []: 
      #As long as we keep the frontier sorted as desired, we can retrieve 1st element
      i = frontier[0]                            
      visited_nodes_in_order.append(i[1].ID)                     #Visit the node 
      if i[1].ID==goal_node: return visited_nodes_in_order       #Terminal case
      #We maintain a temporary list to prepend to frontier to keep it sorted well
      tempFrontierList = []                                      
      childNodes = i[1].connected_nodes 
      for j in childNodes:
        flag = True
        #Check to make sure current child hasn't been encountered before 
        for k in visited_nodes_in_order: 
          if j[1].ID ==k: flag = False      
        for k in frontier: 
          if j == k: flag = False
        if flag==True: tempFrontierList.insert(0,j)
      #Prepend our temporary list to the frontier      
      for j in tempFrontierList: frontier.insert(0,j)
      #Pop visited node from the frontier: It's already been added to visited nodes
      frontier.remove(i) 
    #DFS will still print the nodes it has visited even if it doesn't reach its goal state 
    return visited_nodes_in_order 
  
def iterative_deepening_depth_first_search(starting_node, goal_node):
    """
    This function implements the iterative deepening depth first search algorithm
    
    Parameters:
    - starting_node: The entry node into the graph
    - goal_node: The integer ID of the goal node.
    
    Returns:
    A list containing the visited node ids in order they were visited with starting node
    always being the first node and the goal node always being the last
    """
    visited_nodes_in_order = []                       #initialized to null
    currDepth=0                                       #we start at root depth
    #Infinite loop breaks on terminal condition
    while True:                                           
    #Runs DLS and appends it to the visited list 
      result = initialDLS(starting_node, goal_node, currDepth)
      for i in result: 
        visited_nodes_in_order.append(i) 
      #check the terminal condition 
      if visited_nodes_in_order[len(visited_nodes_in_order)-1]==goal_node: 
        return visited_nodes_in_order 
      currDepth = currDepth+1
      #We assume that after 20 iterations that no such goal exists and can just return 
      if currDepth > 20 : break 
    return visited_nodes_in_order                      #exit on failure to find goal
  
"""
This code algorithmically performs identically to the DLS method that I initially
wrote, however since the root node 0 is represented as a node data structure and 
its connected nodes are represented as tuples, I essentially overloaded the method 
so that it doesn't crash when looking for a tuples ID fields and whatnot. 

This method is only called on the root node. DLS is ran for most nodes. 
"""
def initialDLS(starting_node, goal_node, depth):  
    toReturn = [] 
    toReturn.append(starting_node.ID) 
    #If we find our goal, or are on our max depth then we can return 
    if starting_node.ID == goal_node: return toReturn 
    if depth == 0 : return toReturn 
    #This case will likely never occur, but return nothing for edge cases 
    if depth < 0 : return [] 
    #Run DLS recursively on child nodes with one less depth
    frontier = starting_node.connected_nodes 
    for i in frontier: 
      nodeList = DLS(i, goal_node, depth-1)
      for j in nodeList: toReturn.append(j)
      if nodeList[len(nodeList)-1]==goal_node: return toReturn
    return toReturn
 
"""
DLS geared specifically for tuple data structures: this is called on all child nodes.
If we have found our goal or have reached max depth, then we can return it (where 
the node's ID will be appended to the visited list). Else we iterate through the 
children recursively at decremented depth, starting from left children in a DFS 
manner. 
"""
def DLS(starting_node, goal_node, depth): 
    """
    This function takes in the root node and the depth it is allowed to reach
    It will do a DFS with the given limit, and return the nodes it visits. 
    """
    toReturn = [] 
    toReturn.append(starting_node[1].ID) 
    #Exit conditions of terminal, or max depth reached 
    if starting_node[1].ID == goal_node: return toReturn 
    if depth == 0 : return toReturn 
    if depth < 0 : return []  
    #Recursively iterate through children at limited depth and append them to return list
    frontier = starting_node[1].connected_nodes 
    for i in frontier: 
      nodeList = DLS(i, goal_node, depth-1)
      for j in nodeList: toReturn.append(j)
      if nodeList[len(nodeList)-1]==goal_node: return toReturn
    #When our children are finished and have been appended to return list we are done 
    return toReturn
    

def a_star_search(starting_node, goal_node):
    """
    This function implements the A* search algorithm
    
    Parameters:
    - starting_node: The entry node into the graph
    - goal_node: The integer ID of the goal node.
    
    Returns:
    A list containing the visited node ids in order they were visited with starting node
    always being the first node and the goal node always being the last
    """
    visited_nodes_in_order = []
    visited_nodes_in_order.append(starting_node.ID) 
    frontier = starting_node.connected_nodes 
    gN = 0
    gnPrev = gN 
    while len(frontier) > 0: 
      currMin = frontier[0][1].heuristic_cost #since nodes are represented as tuples 
      minTravel = frontier[0][0]              #assume travelling to the closest node 
      selectedNode = frontier[0]              #set our selected node to the first one 
      for i in frontier:                      #we are shooting for minimal heuristic value 
        #Try to find f(n) = g(n) + h(n), so look at heuristic and g(n)  
        if i[1].heuristic_cost+i[0] < currMin + minTravel:     
          currMin = i[1].heuristic_cost       #Set the new min heuristic cost 
          minTravel = i[0]
          selectedNode = i                    #Set the pointer to the new optimal node
      gN = gN + minTravel                     #Update travel cost with selected node 
      #Append the node's numeric ID to the list 
      visited_nodes_in_order.append(selectedNode[1].ID) 
      frontier.remove(selectedNode)           #Remove the optimal node from the frontier 
      #If we find our terminal condition then we can simply return 
      if selectedNode[1].ID == goal_node: 
        return visited_nodes_in_order 
      #Get the child nodes to prepend to the frontier 
      childNodes = selectedNode[1].connected_nodes
      tempFrontier = []                       #This will be prepended in order to the frontier 
      #But first we must check to make sure these nodes haven't been explored 
      for i in childNodes: 
        if i[1].ID not in visited_nodes_in_order: tempFrontier.insert(0,i)   
      for i in tempFrontier: 
        frontier.insert(0,i)  
    #Assuming the while loop has terminated, A* failed, so return visited nodes 
    return visited_nodes_in_order

goal_node = 12
depth_first_search_answer = [0, 1, 4, 5, 8, 12]
iterative_deepening_depth_first_search_answer = [0, 0, 1, 2, 3, 0, 1,
                                                 4, 5, 2, 5, 6, 3, 7,
                                                 0, 1, 4, 5, 8, 2, 5,
                                                 8, 6, 9, 10, 3, 7, 11,
                                                 0, 1, 4, 5, 8, 12]
a_star_search_answer = [0, 2, 6, 10, 12]

assert (depth_first_search(build_graph(), goal_node)==depth_first_search_answer)
assert (iterative_deepening_depth_first_search(build_graph(), goal_node)==iterative_deepening_depth_first_search_answer)
assert (a_star_search(build_graph(), goal_node)==a_star_search_answer)